use hdk::prelude::*;
use tracing::Level;
use tracing_subscriber::FmtSubscriber;

mod join_code;
mod offer;
mod peer_profile;

pub use crate::{
    offer::{OfferPayload, OfferSignal},
    peer_profile::{JoinRoomInfo, PeerProfile},
};

// This is part of Holochain data model definition, and here we specify
// what kinds of entries are available in our applicaton.
entry_defs![
    // Our implementation of room_code uses `anchor` helper method,
    // which requires us to add the Anchor and Path entry definitions
    Anchor::entry_def(),
    Path::entry_def(),
    // PeerProfile Holochain entry definition callback. You wouldn't find a fn
    // named entry_def in peer_profile.rs: this is one of the functions
    // generated by applying `#[hdk_entry]` macro to PeerProfile struct
    peer_profile::PeerProfile::entry_def()
];

#[hdk_extern]
fn init(_: ()) -> ExternResult<InitCallbackResult> {
    // ------ first, set up cap grants for signals to work
    // grant unrestricted access to accept_cap_claim so other agents can send us claims
    let mut functions: GrantedFunctions = BTreeSet::new();
    // give unrestricted access to recv_remote_signal, which is needed for sending remote signals
    functions.insert((zome_info()?.name, "recv_remote_signal".into()));

    // Create the simplest capability grant entry
    create_cap_grant(CapGrantEntry {
        tag: "".into(),    // we wouldn't need to use it, so tag can be empty
        access: ().into(), // empty access converts to unrestricted
        functions,         // this grant would allow these functions to be called
    })?;

    // ------ second, set up a tracing config. This isn't related to the signals part in any way:
    // even more so -- this isn't Holochain specific! Just Rust tracing crate.
    // Holochain's init fn is basically an entry point into the hApp (which is the role main function
    // plays in Rust apps), so it's a good place for such setup to be done.
    let subscriber = FmtSubscriber::builder()
        // all spans/events with a level higher than TRACE (e.g, debug, info, warn, etc.)
        // will be written to stdout.
        .with_max_level(Level::TRACE)
        // configures formatter with defaults
        .with_target(false)
        .without_time()
        .compact()
        // completes the builder.
        .finish();
    tracing::subscriber::set_global_default(subscriber).expect("setting default subscriber failed");

    // init is an important callback for every hApp, and it's return value is
    // critical for what happens next, so there are multiple different values defined.
    // If we get to this line, everything is going fine: we can safely pass the
    // init stage and move on to the next step.
    Ok(InitCallbackResult::Pass)
}

/// Function to handle signals we receive from other backend nodes
/// It's purpose is simple: receive a remote signal and emit a local
/// signal to the UI so it can react on it
#[hdk_extern]
fn recv_remote_signal(signal: ExternIO) -> ExternResult<()> {
    // Try to decode signal data we received into RoomSignal
    let offer_signal_result: Result<OfferSignal, SerializedBytesError> = signal.decode();
    // Handle possible decoding errors
    match offer_signal_result {
        // No decoding errors, so we emit local signal to the UI
        Ok(a) => emit_signal(a),
        // Decoding errors, so we just return an error
        Err(e) => {
            info!("signal error {:?}", e);
            Err(WasmError::Guest("Remote signal failed".into()))
        }
    }
}

/// This is another macro applied to the function that follows, and we need it to
/// expose this function as part of our backend API
/// Note that this macro requires fn to accept input parameters, so if your fn
/// doesn't accept anything, write it's signature like this:
/// ```
/// #[hdk_extern]
/// fn foo(_: ()) -> ExternResult<EntryHash>
/// ```
/// This function is part of our publicly exposed API and it simply wraps
/// the corresponding function in room_code module.
#[hdk_extern]
pub fn create_room_code_anchor(short_unique_code: String) -> ExternResult<EntryHash> {
    join_code::create_room_code_anchor(short_unique_code)
}

/// Creates a user profile and links it to the room_code
#[hdk_extern]
pub fn join_room_with_code(input: JoinRoomInfo) -> ExternResult<EntryHash> {
    peer_profile::join_room_with_code(input)
}

/// Lists all peers who are linked to the room_code
#[hdk_extern]
pub fn get_peers_for_room_code(short_unique_code: String) -> ExternResult<Vec<PeerProfile>> {
    peer_profile::get_peer_profiles_for_room_code(short_unique_code)
}

#[hdk_extern]
pub fn send_offer(input: OfferPayload) -> ExternResult<()> {
    peer_profile::send_offer(input.into())
}

#[hdk_extern]
pub fn send_answer(input: OfferPayload) -> ExternResult<()> {
    peer_profile::send_answer(input.into())
}
